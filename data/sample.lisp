;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq! lst (unionql '(1 2 3) '(4 5 6)))
(test "initial lst"     (6 5 4 3 2 1) lst)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "memql? 2"        t (memql?   3 lst))
(test "removeql 4"      (6 5 3 2 1) (removeql 4 lst))
(test "indexql 5"       1 (indexql  5 lst))
(test "mapcar!"         (12 10 8 6 4 2) (mapcar! double lst))
(test "butlast"         (1 2 3 4) (butlast '(1 2 3 4 5)))
(test "reverse"         (5 4 3 2 1) (reverse '(1 2 3 4 5)))
(test "reverse butlast" (4 3 2 1) (reverse (butlast '(1 2 3 4 5))))
(test "union"           (6 5 4 3 2 1) (unionql '(1 2 3) '(4 5 6)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq! lst (make-list 6 200))
(test "make-list"       (200 200 200 200 200 200) lst)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(list-set! lst 0 100)
(test "list-set! 0 100" (100 200 200 200 200 200) lst)
(test "list-ref  0"     100 (list-ref lst 0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(list-set! lst 1 101)
(test "list-set! 1 101" (100 101 200 200 200 200) lst)
(test "list-ref  1"     101 (list-ref lst 1))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
(list-set! lst 2 102)
(test "list-set! 2 102" (100 101 102 200 200 200) lst)
(test "list-ref  2"     102 (list-ref lst 2))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
(list-set! lst 3 103)
(test "list-set! 3 103" (100 101 102 103 200 200) lst)
(test "list-ref  3"     103 (list-ref lst 3))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                        
(list-set! lst 4 104)
(test "list-set! 4 104" (100 101 102 103 104 200) lst)
(test "list-ref  4"     104 (list-ref lst 4))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
(list-set! lst 5 105)
(test "list-set! 5 105" (100 101 102 103 104 105) lst)
(test "list-ref  5"     105 (list-ref lst 5))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun lshift4 (n) (<< n 4))
(add-logging-to lshift4)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "lshft4 body"
 (progn
  (princ "Applying " 'lshift4 " to parameters " (syms (env)) " with arguments " (vals (env)) ".") (nl)
  (let ((result (progn (<< n 4))))
   (princ "Result of applying " 'lshift4 " was " result ".") (nl)
   result))
 (body lshift4))
(test "lshift4" 64 (lshift4 4))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
(setq! lst $(2 4 1 5 3 7 9 6 8))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "samtf!" (9 2 4 1 5 3 7 6 8) (progn (select-and-move-to-front! (lambda (o) (eql? o 9)) lst) lst))
(test "samtf!" (8 9 2 4 1 5 3 7 6) (progn (select-and-move-to-front! (lambda (o) (eql? o 8)) lst) lst))
(test "samtf!" (7 8 9 2 4 1 5 3 6) (progn (select-and-move-to-front! (lambda (o) (eql? o 7)) lst) lst))
(test "samtf!" (6 7 8 9 2 4 1 5 3) (progn (select-and-move-to-front! (lambda (o) (eql? o 6)) lst) lst))
(test "samtf!" (5 6 7 8 9 2 4 1 3) (progn (select-and-move-to-front! (lambda (o) (eql? o 5)) lst) lst))
(test "samtf!" (4 5 6 7 8 9 2 1 3) (progn (select-and-move-to-front! (lambda (o) (eql? o 4)) lst) lst))
(test "samtf!" (3 4 5 6 7 8 9 2 1) (progn (select-and-move-to-front! (lambda (o) (eql? o 3)) lst) lst))
(test "samtf!" (2 3 4 5 6 7 8 9 1) (progn (select-and-move-to-front! (lambda (o) (eql? o 2)) lst) lst))
(test "samtf!" (1 2 3 4 5 6 7 8 9) (progn (select-and-move-to-front! (lambda (o) (eql? o 1)) lst) lst))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "nthcdr 0" (1 2 3 4 5 6 7 8 9) (nthcdr 0 lst))
(test "nthcdr 1" (2 3 4 5 6 7 8 9)   (nthcdr 1 lst))
(test "nthcdr 2" (3 4 5 6 7 8 9)     (nthcdr 2 lst))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq! c (curry1 nthcdr 3))
(test "c" (4 5 6 7 8 9) (c lst))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "pop!" 1 (pop! lst))
(test "push!"  (99 2 3 4 5 6 7 8 9)  (push! 99 lst))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(ignore
 "This would result (deliberately) in an invalid call, so we ignore it for now."
 "It remains here only to serve as an example."
 ;; a deliberate invalid call:
 (nl) (princ "AN ERROR WILL FOLLOW: ") (nl)
 ;; (log-eval t)
 (s x 2 3))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This one triggers an indentation bug, investigate:
;; (defun split-list (pred? lst)
;;  (let ((front nil)
;;        (current lst))
;;   (while (and current (funcall pred? (car current)))
;;    (setq front (cons (car current) front))
;;    (setq current (cdr current)))
;;   $((fake-reverse front) current)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(s lst  '("asdw" "erer" "rerw" 1 nil (lambda (x) x) zoop z (1 2 . 3) 8))
(s split (split-list string? lst))
(ignore
 "This test cannot work until handling of strings containing escaped double quotes is fixed,"
 "and so for now we will ignore it."
 (test "front" "\"asdw erer rerw\"" (apply concat (intercalate " " (car split)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "back" (1 nil (lambda (x) x) zoop z (1 2 . 3) 8) (cadr split))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(ignore
 (defmacro defun (name params . docs-and-body)
  (let* ((split (split-list string? docs-and-body))
         (docs  (apply concat (intercalate " " (car split))))
         (body  (cadr split)))
   $('progn 
     $('setq! name $('lambda params . body))
     $('put! docs ':doc name))))

 (defun somefun (x y)
  "Multiply two"
  "numbers."
  (* x y))

 (write (get :doc somefun)) (nl)
 
 (write (doc somefun)) (nl)
 (write (doc write)) (nl))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun binlist-to-dec-1 (lst)
 (letrec
  ((chase
    (lambda (acc lst)
     (if (nil? lst)
      acc
      (chase (+ (<< acc 1) (car lst)) (cdr lst))))))
  (chase 0 lst)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun binlist-to-dec-2 (lst) (reduce   (lambda (x y) (+ (<< x 1) y)) lst 0))
(setq! binlist-to-dec-3       (reduced  (lambda (x y) (+ (<< x 1) y))))
(setq! bins-to-dec            (reduced* (lambda (x y) (+ (<< x 1) y))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "binlist-to-dec-1" 85 (binlist-to-dec-1 '(1 0 1 0 1 0 1))) ;; ⇒ 85
(test "binlist-to-dec-2" 85 (binlist-to-dec-2 '(1 0 1 0 1 0 1))) ;; ⇒ 85
(test "binlist-to-dec-3" 85 (binlist-to-dec-3 '(1 0 1 0 1 0 1))) ;; ⇒ 85
(test "bins-to-dec"      85 (bins-to-dec        1 0 1 0 1 0 1))  ;; ⇒ 85
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
(test "lr   #1" nil (reduce  + '()))
(test "lr   #2" 1   (reduce  + '(1)))
(test "lr   #3" 3   (reduce  + '(1 2)))
(test "lr   #4" 6   (reduce  + '(1 2 3)))
(test "lr   #5" 10  (reduce  + '(1 2 3 4)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
(test "lr 0 #1" 0   (reduce  + '()         0))
(test "lr 0 #2" 1   (reduce  + '(1)        0))
(test "lr 0 #3" 3   (reduce  + '(1 2)      0))
(test "lr 0 #4" 6   (reduce  + '(1 2 3)    0))
(test "lr 0 #5" 10  (reduce  + '(1 2 3 4)  0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
(test "rr   #1" nil (rreduce + '()))
(test "rr   #2" 1   (rreduce + '(1)))
(test "rr   #3" 3   (rreduce + '(1 2)))
(test "rr   #4" 6   (rreduce + '(1 2 3)))
(test "rr   #5" 10  (rreduce + '(1 2 3 4)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
(test "rr 0 #1" 0   (rreduce + '()         0))
(test "rr 0 #2" 1   (rreduce + '(1)        0))
(test "rr 0 #3" 3   (rreduce + '(1 2)      0))
(test "rr 0 #4" 6   (rreduce + '(1 2 3)    0))
(test "rr 0 #5" 10  (rreduce + '(1 2 3 4)  0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test "zipped 2" ((a 1) (b 2) (c 3))       (zip '(a b c) '(1 2 3)))
(test "zipped 3" ((a 1 x) (b 2 y) (c 3 z)) (zip '(a b c) '(1 2 3) '(x y z)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq mylist '(7 5 4 6 3 9 1 6 2 8 6))
(defun less-than (a b) (< a b))
(test "sorted" (1 2 3 4 5 6 6 6 7 8 9) (sort!! mylist less-than))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq mylist '(7 5 4 6 3 9 1 6 2 8 6))
(test "sorted" (1 2 3 4 5 6 6 6 7 8 9) (sort!! mylist <))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq! sum (reduced* +))
(test "#1 l this*   == 10" 10 (sum  1 2 3 4))
(setq! sum (reduced* + 4))
(test "#2 l this* 4 == 10" 10 (sum  1 2 3))
(setq! sum (rreduced* +))
(test "#3 r this*   == 10" 10 (sum  1 2 3 4))
(setq! sum (rreduced* + 4))
(test "#4 r this* 4 == 10" 10 (sum  1 2 3))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq! sum (reduced  +))
(test "#5 l this    == 10" 10 (sum '(1 2 3 4)))
(setq! sum (reduced  + 4))
(test "#6 l this  4 == 10" 10 (sum '(1 2 3)))
(setq! sum (rreduced  +))
(test "#7 r this    == 10" 10 (sum '(1 2 3 4)))
(setq! sum (rreduced  + 4))
(test "#8 r this  4 == 10" 10 (sum '(1 2 3)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(nl)
(princ "All tests passed.")
(nl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
