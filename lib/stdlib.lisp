;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq char?     (lambda (x) (eq :CHAR     (type x))))
(setq cons?     (lambda (x) (eq :CONS     (type x))))
(setq core?     (lambda (x) (eq :CORE     (type x))))
(setq env?      (lambda (x) (eq :ENV      (type x))))
(setq error?    (lambda (x) (eq :ERROR    (type x))))
(setq float?    (lambda (x) (eq :FLOAT    (type x))))
(setq integer?  (lambda (x) (eq :INTEGER  (type x))))
(setq invalid?  (lambda (x) (eq :INVALID  (type x))))
(setq lambda?   (lambda (x) (eq :LAMBDA   (type x))))
(setq macro?    (lambda (x) (eq :MACRO    (type x))))
(setq rational? (lambda (x) (eq :RATIONAL (type x))))
(setq string?   (lambda (x) (eq :STRING   (type x))))
(setq symbol?   (lambda (x) (eq :SYMBOL   (type x))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq transform!
 (lambda (expr pred fun)
  (if (not (eq :CONS (type expr)))
   (error "expr must be a list")
   (cond
    ((pred expr) (setf expr (fun expr)))
    ((eq :CONS (type expr))
     (let ((head (car expr))
           (tail (cdr expr)))
      (cond
       ((pred head) (rplaca expr (fun head)))
       ((eq :CONS (type head))  (transform! head pred fun)))
      (cond
       ((pred tail) (rplacd expr (fun tail)))
       ((eq :CONS (type tail))  (rplacd expr (transform! tail pred fun))))))
    (t expr))
   expr)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq benchmark
 (lambda (repetitions print-interval qexpr)
  (nl)
  (let ((ctr 0 )
        (total 0))
   (repeat repetitions
    (setq ctr (+ 1 ctr))
    (let ((before (time)))
     (eval qexpr)
     (setq total (+ total (elapsed before))))
    (when (== 0 (% ctr print-interval))
     (nl)
     (princ "Iteration #")
     (princ ctr)
     (princ ", ")
     (princ (/ total 1000))
     (princ " ms so far.")))
   (nl)
   (princ "total ums: ")
   (princ total) (nl)
   (princ "total ms: ")
   (princ (/ total 1000)) (nl)
   (princ "total s: ")
   (princ (/ total 1000000)) (nl)
   (princ "each ms: ")
   (princ (/ total repetitions 1000)) (nl))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
